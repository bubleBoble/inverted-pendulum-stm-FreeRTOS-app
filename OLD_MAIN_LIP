/*
*   siema
*/

#include "tim.h"
#include "usart.h"
#include "adc.h"

#include <stdio.h>
#include <string.h>
#include "motor_driver.h"
#include "encoder_driver.h"
#include "com_driver.h"
#include "main_LIP.h"

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

TaskHandle_t mytask1_handle = NULL;
void mytask1(void *p);
TaskHandle_t mytask2_handle = NULL;
void mytask2(void *p);
TaskHandle_t mytask3_handle = NULL;
void mytask3(void *p);
TaskHandle_t intTask_handle = NULL;
void intTask(void *p);

TaskHandle_t sender_task_handle = NULL;
void sender_task(void *p);
TaskHandle_t receiver_task_handle = NULL;
void receiver_task(void *p);

xQueueHandle myqueue;

/* task notifications */
TaskHandle_t notif_sender_task_handle = NULL;
void notif_sender_task(void *p);
TaskHandle_t notif_receiver_task_handle = NULL;
void notif_receiver_task(void *p);

TaskHandle_t notif_sender2_handle = NULL;
void notif_sender2(void *p);
TaskHandle_t notif_receiver2_handle = NULL;
void notif_receiver2(void *p);

/* mutex for shared resources */
TaskHandle_t tsk1_handle = NULL;
void tsk1(void *p);
TaskHandle_t tsk2_handle = NULL;
void tsk2(void *p);

char shared_resource_message[10];
SemaphoreHandle_t xmutex;

TaskHandle_t motor_test_task_handle = NULL;
void motor_test_task(void *p);

TaskHandle_t elotask_handle = NULL;
void elotask(void *p);

void main_LIP_init(void)
{
    // Initialize PWM timer and zero its PWM output
    dcm_init_output_voltage();
    // Initialize encoder timer
    enc_init();
}

void main_LIP_run(void)
{
    // xTaskCreate(mytask1, "task1", 200, (void *)0, tskIDLE_PRIORITY+1, &mytask1_handle);
    // xTaskCreate(mytask2, "task2", 200, (void *)0, tskIDLE_PRIORITY+1, &mytask2_handle);
    // xTaskCreate(mytask3, "task3", 200, (void *)0, tskIDLE_PRIORITY+1, &mytask3_handle);
    xTaskCreate(intTask, "intTask", 200, (void *)0, tskIDLE_PRIORITY+1, &intTask_handle);
    // xTaskCreate(sender_task, "sender task", 100, (void *)0, tskIDLE_PRIORITY+1, &sender_task_handle);
    // xTaskCreate(receiver_task, "receiver task", 100, (void *)0, tskIDLE_PRIORITY+1, &receiver_task_handle);
    // xTaskCreate(notif_sender_task, "notif sender task", 100, (void *)0, tskIDLE_PRIORITY+1, &notif_sender_task_handle);
    // xTaskCreate(notif_receiver_task, "notif receiver task", 100, (void *)0, tskIDLE_PRIORITY+1, &notif_receiver_task_handle);
    // xTaskCreate(notif_sender2, "sender2", 200, (void *)0, tskIDLE_PRIORITY+1, &notif_sender2_handle);
    // xTaskCreate(notif_receiver2, "receiver2", 200, (void *)0, tskIDLE_PRIORITY+1, &notif_receiver2_handle);
    // xTaskCreate(tsk1, "tsk1", 200, (void *)0, tskIDLE_PRIORITY+2, &tsk1_handle);
    // xTaskCreate(tsk2, "tsk2", 200, (void *)0, tskIDLE_PRIORITY+2, &tsk2_handle);
    // xTaskCreate(motor_test_task, "motor test task", 200, (void *)0, tskIDLE_PRIORITY+1, &motor_test_task_handle);
    xTaskCreate(elotask, "elotask", 200, (void *)0, tskIDLE_PRIORITY+1, &elotask_handle);

    xmutex = xSemaphoreCreateMutex();

    vTaskStartScheduler();

    while (1)
    {
        // empty palce, so called void
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Interrupt
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Callback function for stateBtn interrupt */
// void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
// {
//     /* Check if an interrupt is on line 13 */
//     if (GPIO_Pin == state_btn_Pin)
//     {
//         BaseType_t xYieldRequired;
//         xYieldRequired = xTaskResumeFromISR(intTask_handle);
//         portYIELD_FROM_ISR(xYieldRequired);
//     } 
//     // else
//     // {
//     //     __NOP();
//     // }
// }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Tasks functions
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void intTask(void *p)
{
    char msg[32] = "BUTTON PRESSED\n";
    for (;;)
    {
        vTaskSuspend(NULL); // suspend itself
        HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 1000);
        HAL_GPIO_TogglePin(led_r_GPIO_Port, led_r_Pin);
        vTaskDelay(200);
    }
}

void mytask1(void *p)
{
    char msg[32] = "\nhello\n";
    const TickType_t delay_ticks = 1000 * 1000 / 1000;
    TickType_t xLastWakeTime = xTaskGetTickCount();;

    for(;;)
    {
        sprintf(msg, "Time: %ld\n", xLastWakeTime);
        HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 20);
        vTaskDelayUntil(&xLastWakeTime, delay_ticks);
    }
}

void mytask2(void *p)
{
    char *msg = ".";
    const TickType_t delay_ticks = 1 * 1000 / 1000;
    TickType_t xLastWakeTime = xTaskGetTickCount();
    
    for(;;)
    {
        HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 20);
        vTaskDelayUntil(&xLastWakeTime, delay_ticks);
    }
}

void mytask3(void *p)
{
    char msg[10] = {0};
    int32_t count = 0;
    const TickType_t delay_ticks = 1000 * 1000 / 1000;
    TickType_t xLastWakeTime = xTaskGetTickCount();
    
    for(;;)
    {
        sprintf(msg, "%ld ", count); count++;
        HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 20);
        vTaskDelayUntil(&xLastWakeTime, delay_ticks);
        if (count == 5)
        {
            HAL_UART_Transmit(&huart3, (uint8_t *)"Deletign the task\n", strlen("Deletign the task\n"), 20);
            vTaskDelete(mytask3_handle);
        }
    }
}

void sender_task(void *p)
{
    char myTxBuffer[30];
    myqueue = xQueueCreate(5, sizeof(myTxBuffer));

    sprintf(myTxBuffer, "msg 1\n");
    xQueueSend(myqueue, (void *) myTxBuffer, (TickType_t) 0);

    sprintf(myTxBuffer, "msg 2\n");
    xQueueSend(myqueue, (void *) myTxBuffer, (TickType_t) 0);

    sprintf(myTxBuffer, "msg 3\n");
    xQueueSend(myqueue, (void *) myTxBuffer, (TickType_t) 0);

    for (;;)
    {
    }   
}
void receiver_task(void *p)
{
    char myRxBuff[30];

    for (;;)
    {
        if(myqueue != NULL)
        {
            if ( xQueueReceive(myqueue, (void *) myRxBuff, (TickType_t) 5 ) )
            {
                HAL_UART_Transmit(&huart3, (uint8_t *)myRxBuff, strlen(myRxBuff), 20);
            }
        }
    }
}
/*
    inne ciekawe funkcje do queue
    queuemessagewaiting   - ile czeka na read
    queuespacesavaliable  - ile jest wolnych miejsc
    xqueuereset           - usuwa wszystko - zostawia pustą kolejke
    queuepeek             - read ale bez usuwania z początku kolejki
    queueoverwrite        - overwrite ostatniego dodanego elementu
*/

/* Task notifications */
void notif_sender_task(void *p)
{
    for(;;)
    {
        xTaskNotifyGive(notif_receiver_task_handle);
        xTaskNotifyGive(notif_receiver_task_handle);
        xTaskNotifyGive(notif_receiver_task_handle);
        xTaskNotifyGive(notif_receiver_task_handle);
        xTaskNotifyGive(notif_receiver_task_handle);
        vTaskDelay(5000);
    }
}
void notif_receiver_task(void *p)
{
    uint32_t notif_val;
    char msg[64];
    for(;;)
    {
        // notif_val = ulTaskNotifyTake(pdTRUE, portMAX_DELAY); // pdTrue (1) to reset notif value
        notif_val = ulTaskNotifyTake(pdFALSE, portMAX_DELAY); // pdFalse (0) to leave notif value as it is

        if (notif_val > 0)
        {
            sprintf(msg, "notif received: %ld\n", notif_val);
            HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 20);
        }
        
    }
}

void notif_sender2(void *p)
{
    xTaskNotify(notif_receiver2_handle, (1<<0), eSetBits);
    xTaskNotify(notif_receiver2_handle, (1<<1), eSetBits);
    xTaskNotify(notif_receiver2_handle, (1<<2), eSetBits);
    // xTaskNotify(notif_receiver2_handle, (1<<0), eNoAction);
    // xTaskNotify(notif_receiver2_handle, (1<<0), eNoAction);
    // xTaskNotify(notif_receiver2_handle, (1<<0), eNoAction);
    // xTaskNotify(notif_receiver2_handle, (1<<0), eNoAction);
    // xTaskNotify(notif_receiver2_handle, (1<<0), eNoAction);

    for(;;)
    {
    }
}
void notif_receiver2(void *p)
{
    uint32_t notif_value;
    char msg[64];
    for(;;)
    {
        xTaskNotifyWait(0, 0, &notif_value, portMAX_DELAY);
        sprintf(msg, "notif received: %ld\n", notif_value);
        HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 20);
    }
}

void tsk1(void *p)
{
    char tsk_msg[] = "Adam\n";
    int i;
    TickType_t time_at_which_mutex_was_taken;

    for(;;)
    {
        // /* mutex on critical section */
        // if(xSemaphoreTake(xmutex, portMAX_DELAY) == pdTRUE)
        // {        
        //     for (i = 0; i < 9; i++)
        //     {
        //         shared_resource_message[i] = tsk_msg[i];
        //         vTaskDelay(50);
        //     }
        //     shared_resource_message[i] = 0;

        //     HAL_UART_Transmit(&huart3, (uint8_t *)shared_resource_message, strlen(shared_resource_message), 20);
        //     xSemaphoreGive(xmutex);
        //     taskYIELD();  // https://forums.freertos.org/t/mutex-never-giving/4977/3
        // }
       
        ////////////////////////////////////////////////////////////
        // Sposób bez if'a
        ////////////////////////////////////////////////////////////

        // Take the mutex that is protecting access to "shared_resource_message"
        xSemaphoreTake(xmutex, portMAX_DELAY);

        // Record the time at which mutex was taken
        time_at_which_mutex_was_taken = xTaskGetTickCount();

        // Critical section start
        for (i = 0; i < 9; i++)
        {
            shared_resource_message[i] = tsk_msg[i];
            vTaskDelay(50);
        }
        shared_resource_message[i] = 0;
        HAL_UART_Transmit(&huart3, (uint8_t *)shared_resource_message, strlen(shared_resource_message), 200);
        // Critical section stop

        xSemaphoreGive(xmutex);

        /* If taskYIELD() was called on each iteration then this task would only ever
        remain in the Running state for a short period of time, and processing time
        would be wasted by rapidly switching between tasks. Therefore, only call
        taskYIELD() if the tick count changed while the mutex was held. */
        if (xTaskGetTickCount() != time_at_which_mutex_was_taken)
            taskYIELD();
    }
}
void tsk2(void *p)
{
    char tsk_msg[] = "Domr\n";
    int i;

    for(;;)
    {
        /* mutex on critical section */
        if(xSemaphoreTake(xmutex, portMAX_DELAY) == pdTRUE)
        {        
            for (i = 0; i < 9; i++)
            {
                shared_resource_message[i] = tsk_msg[i];
                vTaskDelay(50);
            }   
            shared_resource_message[i] = 0;

            HAL_UART_Transmit(&huart3, (uint8_t *)shared_resource_message, strlen(shared_resource_message), 200);
            xSemaphoreGive(xmutex);
            taskYIELD();       
        }
        vTaskDelay(100);
    }
}

void motor_test_task(void *p)
{
    for (;;)
    {
        // dcm_zero_output_voltage();
        // int i = 0;
        // for(i=0; i<=120; i++)
        // {
        //     // float ma pierwszeństwo przed dzieleniem
        //     dcm_set_output_volatage( (float)i / 10.0 );
        //     // enc_count = enc_get_deg();
        //     // sprintf((char*)msg, "%f\n", enc_count);
        //     // HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 1000);
        //     vTaskDelay(100);
        // }
        // vTaskDelay(2000);

        // for(i=120; i>=0; i--)
        // {
        //     dcm_set_output_volatage( (float)i / 10.0 );
        //     // enc_count = enc_get_deg();
        //     // sprintf((char*)msg, "%f\n", enc_count);
        //     // HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 1000);
        //     vTaskDelay(100);
        // }
        // dcm_zero_output_voltage();
        // vTaskDelay(2000);

        // for(i=0; i<=60; i++)
        // {
        //     // type cast ma pierwszeństwo przed dzieleniem
        //     dcm_set_output_volatage( -(float)i / 10.0 );
        //     // enc_count = enc_get_deg();
        //     // sprintf((char*)msg, "%f\n", enc_count);
        //     // HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 1000);
        //     vTaskDelay(200);
        //     // HAL_Delay(200);
        // }

        // for(i=60; i>=0; i--)
        // {
        //     dcm_set_output_volatage( -(float)i / 10.0 );
        //     // enc_count = enc_get_deg();
        //     // sprintf((char*)msg, "%f\n", enc_count);
        //     // HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 1000);
        //     vTaskDelay(200);
        //     // HAL_Delay(40);
        // }
        // dcm_zero_output_voltage();
        // HAL_Delay(500);
    }
}

void elotask(void *p)
{
    uint32_t pot_adc_read = 0;
    char msg[64];
    float slope = 12.0f/2048.0f;
    float voltage_setting = 0.0f;
    // HAL_ADCEx_Calibration_Start(&hadc3);
    // adc resol = 12 bit = 0-4096 range
    for (;;)
    {
        // HAL_ADC_Start(&hadc3);
        // HAL_ADC_PollForConversion(&hadc3, 1);
        // pot_adc_read = HAL_ADC_GetValue(&hadc3);
        // voltage_setting = slope * pot_adc_read - 12.0f;
        // sprintf((char*)msg, "%f\n", voltage_setting);
        // HAL_UART_Transmit(&huart3, (uint8_t *)msg, strlen(msg), 1000);

        if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13))
        {
            // dcm_set_output_volatage(voltage_setting);
            dcm_set_output_volatage(4.0f);
            vTaskDelay(700);    
            dcm_set_output_volatage(-4.0f);
            vTaskDelay(700);
        }
        else 
        {
            dcm_set_output_volatage(0.0f);
            vTaskDelay(200);
        }
        

    }
}
