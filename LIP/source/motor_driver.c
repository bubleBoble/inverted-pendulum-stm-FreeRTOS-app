/*
 * Description: Basic interface for dcmotor
 *
 * Created at: 20/09/2023
 *
 * Notes:
 * 	Timer for PWM motor control is tim3 (TIMER_HANDLE=htim3) (APB1@84MHz)
 * 	on CH1 & CH2
 *
 * 	PSC set @ 83 (84)
 * 	ARR set @ 999 (1000)
 *	Auto-reload preload: enabled
 *	Counter mode: up
 *
 *	GPIOs used: PA6 for CH1 (pwm1_dcmA1 in IDE)
 *		    PA7 for CH2 (pwm2_dcmA2 in IDE)
 *
 */

#include "tim.h" // from autogenerated code
// #include "adc.h" // from autogenerated code
#include "motor_driver.h"

float dutycycle; // PWM dutycycle of currently active PWM timer channel

float voltage_sign = 1.0f; // 1 for positive, -1 for negative output voltage
								  		 		
/*
 * Function to initialize pwm GPIOs and set initial pwm to 0 DC
 */
void dcm_init(void)
{

    // start timer
    HAL_TIM_PWM_Start( &TIMER_HANDLE, TIM_CHANNEL_1 );
    HAL_TIM_PWM_Start( &TIMER_HANDLE, TIM_CHANNEL_2 );
    // set initial dutycycle to zero on both channels
    // or use dcm_set_output_voltage(0); instead
    dcm_set_ch1_dutycycle( 0 ); // ch1 to 0% duty cycle
    dcm_set_ch1_dutycycle( 0 ); // ch2 to 0% duty cycle
}

/*
 * Function to zero the output voltage
 */
void dcm_zero_output_voltage(void)
{
    dcm_set_ch1_dutycycle( 0 );
    dcm_set_ch2_dutycycle( 0 );
}

/*
 * Function to set output voltage in range [-12, 12]V
 */
void dcm_set_output_volatage( float inV )
{
    if ( inV >= 0 ) // ch1>0V, ch2=0V
    {
		if ( inV > MAX_INPUT_VOLTAGE_POSITIVE )
		{
			inV = MAX_INPUT_VOLTAGE_POSITIVE;
		}
		dutycycle = inV / MAX_INPUT_VOLTAGE_POSITIVE;     // normalize to [0, 1] range
		dutycycle = dutycycle * 1000.0;                   // map to value in [0, 1000] range
		dcm_set_ch2_dutycycle( 0 );                       // zero the other channel first
		dcm_set_ch1_dutycycle( (uint16_t)dutycycle );     // could be round((uint16_t)_dutycycle) but cast is fine
		voltage_sign = 1.0f;
	}
    else if ( inV < 0 ) // ch1=0V, ch2>0V
    {
		if ( inV < MAX_INPUT_VOLTAGE_NEGATIVE )
		{
			inV = MAX_INPUT_VOLTAGE_NEGATIVE;
		}
		dutycycle = inV / MAX_INPUT_VOLTAGE_NEGATIVE;   // normalize to [0, 1] range
		dutycycle = dutycycle * 1000.0;                 // map to value in [0, 1000] range
		dcm_set_ch1_dutycycle( 0 );                     // zero the other channel first
		dcm_set_ch2_dutycycle( (uint16_t)dutycycle );   // could be round((uint16_t)_dutycycle) but cast is fine
		voltage_sign = -1.0f;
	}
}

/*
 * Function returns current output voltage setting
 * calculated from the value of dutycycle
 */
float dcm_get_output_voltage( void )
{
	return ( dutycycle / 1000.0f * MAX_INPUT_VOLTAGE_POSITIVE * voltage_sign );
}

/*
 * Sets dutycycle for ch1&ch2 pwm
 * dtc argument ranges between 0 and 1000 (ARR+1 ??? +1 czy nie?)
 */
void dcm_set_ch1_dutycycle(uint16_t dtc)
{
    __HAL_TIM_SET_COMPARE(&TIMER_HANDLE, TIM_CHANNEL_1, dtc);
}

void dcm_set_ch2_dutycycle(uint16_t dtc)
{
    __HAL_TIM_SET_COMPARE(&TIMER_HANDLE, TIM_CHANNEL_2, dtc);
}


